<!--
// Copyright © 2020 Anticrm Platform Contributors.
// 
// Licensed under the Eclipse Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License. You may
// obtain a copy of the License at https://www.eclipse.org/legal/epl-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// 
// See the License for the specific language governing permissions and
// limitations under the License.
-->

<script type="ts">
  import ScrollView from '@anticrm/sparkling-controls/src/ScrollView.svelte'
  import ReferenceInput from '@anticrm/presentation/src/components/refinput/ReferenceInput.svelte'
  import ChatMessageItem from './ChatMessageItem.svelte'
  import { onDestroy } from 'svelte'
  import core, { QueryResult } from '@anticrm/platform-core';
  import { Ref, Space, StringProperty, VDoc } from '@anticrm/core'
  import { getChunterService, getCoreService } from '../../utils'
  import chunter, { Message } from '../..'
  import contact from '@anticrm/contact'

  const coreService = getCoreService()
  const chunterService = getChunterService()

  export let space: Ref<Space>

  let spaceName: string
  let messages: Message[] = []
  let chatUsers: Set<string> = new Set<string>()
  let unsubscribe: () => void

  function subscribe(queryResult: QueryResult<Message>) {
    if (unsubscribe) unsubscribe()
    unsubscribe = queryResult.subscribe(docs => messages = docs)
  }

  $: {
    coreService.then(service => service.query(chunter.class.Message, { _space: space })).then(queryResult => subscribe(queryResult))

    // TODO: use Titles index instead of getting the whole Space object
    coreService.then(service => service.findOne(core.class.Space, { _id: space })).then(spaceObj => spaceName = spaceObj ? '#' + spaceObj.name : '')
  }

  // get list of users in the chat
  coreService.then(service => service.findOne(core.class.Space, { _id: space })).then(spaceObj =>{
    if (spaceObj && spaceObj.users) {
      for (let u of spaceObj.users) {
        // TODO: should make one request for all users
        coreService.then(service => service.findOne(contact.mixin.User, { account: u as StringProperty })).then(res => {
          if (res) {
            chatUsers = chatUsers.add(res.name)
            console.log(`added user '${res.name}'`)
          }
        })
      }
    }
  })

  onDestroy(() => { if(unsubscribe) unsubscribe() })

  function createMessage(message: string) {
    if (message) {
      chunterService.then(chunterService => {
        const parsedMessage = chunterService.createMissedObjects(message)
        coreService.then(coreService => {
          const newMessage = { _class: chunter.class.Message, _space: space, message: parsedMessage }
          // absent VDoc fields will be autofilled
          coreService.createVDoc(newMessage as unknown as VDoc)
        })
      })
    }
  }
</script>

<div class="chat">
  <div>
    <span class="caption-1">Чат {spaceName}</span>&nbsp;
  </div>
  <div>
    <span class="caption-4">Пользователи в чате: </span>
    { #each Array.from(chatUsers.values()) as username, i }
      <span>{username}</span>
      { #if i < chatUsers.size-1 }
        <span>,&nbsp;</span>
      { /if }
    { /each }
  </div>
  <ScrollView stylez="height:100%;" autoscroll=true>
    <div class="content">
      { #each messages as message (message._id) }
          <ChatMessageItem message={message} />
      { /each }
    </div>
  </ScrollView>
  <div>
    <ReferenceInput on:message={e => createMessage(e.detail)}/>
  </div>
</div>

<style lang="scss">
  .chat {
    height: 100%;
    display: flex;
    flex-direction: column;  

    .content {
      flex-grow: 1;
    }
  }
</style>
